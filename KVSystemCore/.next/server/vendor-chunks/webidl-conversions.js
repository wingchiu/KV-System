"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webidl-conversions";
exports.ids = ["vendor-chunks/webidl-conversions"];
exports.modules = {

/***/ "(ssr)/./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((module) => {

eval("\r\n\r\nvar conversions = {};\r\nmodule.exports = conversions;\r\n\r\nfunction sign(x) {\r\n    return x < 0 ? -1 : 1;\r\n}\r\n\r\nfunction evenRound(x) {\r\n    // Round x to the nearest integer, choosing the even integer if it lies halfway between two.\r\n    if ((x % 1) === 0.5 && (x & 1) === 0) { // [even number].5; round down (i.e. floor)\r\n        return Math.floor(x);\r\n    } else {\r\n        return Math.round(x);\r\n    }\r\n}\r\n\r\nfunction createNumberConversion(bitLength, typeOpts) {\r\n    if (!typeOpts.unsigned) {\r\n        --bitLength;\r\n    }\r\n    const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);\r\n    const upperBound = Math.pow(2, bitLength) - 1;\r\n\r\n    const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);\r\n    const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);\r\n\r\n    return function(V, opts) {\r\n        if (!opts) opts = {};\r\n\r\n        let x = +V;\r\n\r\n        if (opts.enforceRange) {\r\n            if (!Number.isFinite(x)) {\r\n                throw new TypeError(\"Argument is not a finite number\");\r\n            }\r\n\r\n            x = sign(x) * Math.floor(Math.abs(x));\r\n            if (x < lowerBound || x > upperBound) {\r\n                throw new TypeError(\"Argument is not in byte range\");\r\n            }\r\n\r\n            return x;\r\n        }\r\n\r\n        if (!isNaN(x) && opts.clamp) {\r\n            x = evenRound(x);\r\n\r\n            if (x < lowerBound) x = lowerBound;\r\n            if (x > upperBound) x = upperBound;\r\n            return x;\r\n        }\r\n\r\n        if (!Number.isFinite(x) || x === 0) {\r\n            return 0;\r\n        }\r\n\r\n        x = sign(x) * Math.floor(Math.abs(x));\r\n        x = x % moduloVal;\r\n\r\n        if (!typeOpts.unsigned && x >= moduloBound) {\r\n            return x - moduloVal;\r\n        } else if (typeOpts.unsigned) {\r\n            if (x < 0) {\r\n              x += moduloVal;\r\n            } else if (x === -0) { // don't return negative zero\r\n              return 0;\r\n            }\r\n        }\r\n\r\n        return x;\r\n    }\r\n}\r\n\r\nconversions[\"void\"] = function () {\r\n    return undefined;\r\n};\r\n\r\nconversions[\"boolean\"] = function (val) {\r\n    return !!val;\r\n};\r\n\r\nconversions[\"byte\"] = createNumberConversion(8, { unsigned: false });\r\nconversions[\"octet\"] = createNumberConversion(8, { unsigned: true });\r\n\r\nconversions[\"short\"] = createNumberConversion(16, { unsigned: false });\r\nconversions[\"unsigned short\"] = createNumberConversion(16, { unsigned: true });\r\n\r\nconversions[\"long\"] = createNumberConversion(32, { unsigned: false });\r\nconversions[\"unsigned long\"] = createNumberConversion(32, { unsigned: true });\r\n\r\nconversions[\"long long\"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });\r\nconversions[\"unsigned long long\"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });\r\n\r\nconversions[\"double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (!Number.isFinite(x)) {\r\n        throw new TypeError(\"Argument is not a finite floating-point value\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"unrestricted double\"] = function (V) {\r\n    const x = +V;\r\n\r\n    if (isNaN(x)) {\r\n        throw new TypeError(\"Argument is NaN\");\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\n// not quite valid, but good enough for JS\r\nconversions[\"float\"] = conversions[\"double\"];\r\nconversions[\"unrestricted float\"] = conversions[\"unrestricted double\"];\r\n\r\nconversions[\"DOMString\"] = function (V, opts) {\r\n    if (!opts) opts = {};\r\n\r\n    if (opts.treatNullAsEmptyString && V === null) {\r\n        return \"\";\r\n    }\r\n\r\n    return String(V);\r\n};\r\n\r\nconversions[\"ByteString\"] = function (V, opts) {\r\n    const x = String(V);\r\n    let c = undefined;\r\n    for (let i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\r\n        if (c > 255) {\r\n            throw new TypeError(\"Argument is not a valid bytestring\");\r\n        }\r\n    }\r\n\r\n    return x;\r\n};\r\n\r\nconversions[\"USVString\"] = function (V) {\r\n    const S = String(V);\r\n    const n = S.length;\r\n    const U = [];\r\n    for (let i = 0; i < n; ++i) {\r\n        const c = S.charCodeAt(i);\r\n        if (c < 0xD800 || c > 0xDFFF) {\r\n            U.push(String.fromCodePoint(c));\r\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\r\n            U.push(String.fromCodePoint(0xFFFD));\r\n        } else {\r\n            if (i === n - 1) {\r\n                U.push(String.fromCodePoint(0xFFFD));\r\n            } else {\r\n                const d = S.charCodeAt(i + 1);\r\n                if (0xDC00 <= d && d <= 0xDFFF) {\r\n                    const a = c & 0x3FF;\r\n                    const b = d & 0x3FF;\r\n                    U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\r\n                    ++i;\r\n                } else {\r\n                    U.push(String.fromCodePoint(0xFFFD));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return U.join('');\r\n};\r\n\r\nconversions[\"Date\"] = function (V, opts) {\r\n    if (!(V instanceof Date)) {\r\n        throw new TypeError(\"Argument is not a Date object\");\r\n    }\r\n    if (isNaN(V)) {\r\n        return undefined;\r\n    }\r\n\r\n    return V;\r\n};\r\n\r\nconversions[\"RegExp\"] = function (V, opts) {\r\n    if (!(V instanceof RegExp)) {\r\n        V = new RegExp(V);\r\n    }\r\n\r\n    return V;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG9CQUFvQjtBQUNoRTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsaUJBQWlCO0FBQ25FLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQSxvREFBb0QsaUJBQWlCO0FBQ3JFLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQSx3REFBd0Qsc0NBQXNDO0FBQzlGLGlFQUFpRSxxQ0FBcUM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3B1YmxpY2lzLWt2LXN5c3RlbS8uL25vZGVfbW9kdWxlcy93ZWJpZGwtY29udmVyc2lvbnMvbGliL2luZGV4LmpzPzVkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG52YXIgY29udmVyc2lvbnMgPSB7fTtcclxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXJzaW9ucztcclxuXHJcbmZ1bmN0aW9uIHNpZ24oeCkge1xyXG4gICAgcmV0dXJuIHggPCAwID8gLTEgOiAxO1xyXG59XHJcblxyXG5mdW5jdGlvbiBldmVuUm91bmQoeCkge1xyXG4gICAgLy8gUm91bmQgeCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLCBjaG9vc2luZyB0aGUgZXZlbiBpbnRlZ2VyIGlmIGl0IGxpZXMgaGFsZndheSBiZXR3ZWVuIHR3by5cclxuICAgIGlmICgoeCAlIDEpID09PSAwLjUgJiYgKHggJiAxKSA9PT0gMCkgeyAvLyBbZXZlbiBudW1iZXJdLjU7IHJvdW5kIGRvd24gKGkuZS4gZmxvb3IpXHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoeCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKGJpdExlbmd0aCwgdHlwZU9wdHMpIHtcclxuICAgIGlmICghdHlwZU9wdHMudW5zaWduZWQpIHtcclxuICAgICAgICAtLWJpdExlbmd0aDtcclxuICAgIH1cclxuICAgIGNvbnN0IGxvd2VyQm91bmQgPSB0eXBlT3B0cy51bnNpZ25lZCA/IDAgOiAtTWF0aC5wb3coMiwgYml0TGVuZ3RoKTtcclxuICAgIGNvbnN0IHVwcGVyQm91bmQgPSBNYXRoLnBvdygyLCBiaXRMZW5ndGgpIC0gMTtcclxuXHJcbiAgICBjb25zdCBtb2R1bG9WYWwgPSB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGggPyBNYXRoLnBvdygyLCB0eXBlT3B0cy5tb2R1bG9CaXRMZW5ndGgpIDogTWF0aC5wb3coMiwgYml0TGVuZ3RoKTtcclxuICAgIGNvbnN0IG1vZHVsb0JvdW5kID0gdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoID8gTWF0aC5wb3coMiwgdHlwZU9wdHMubW9kdWxvQml0TGVuZ3RoIC0gMSkgOiBNYXRoLnBvdygyLCBiaXRMZW5ndGggLSAxKTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oViwgb3B0cykge1xyXG4gICAgICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xyXG5cclxuICAgICAgICBsZXQgeCA9ICtWO1xyXG5cclxuICAgICAgICBpZiAob3B0cy5lbmZvcmNlUmFuZ2UpIHtcclxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSBmaW5pdGUgbnVtYmVyXCIpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB4ID0gc2lnbih4KSAqIE1hdGguZmxvb3IoTWF0aC5hYnMoeCkpO1xyXG4gICAgICAgICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgaW4gYnl0ZSByYW5nZVwiKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzTmFOKHgpICYmIG9wdHMuY2xhbXApIHtcclxuICAgICAgICAgICAgeCA9IGV2ZW5Sb3VuZCh4KTtcclxuXHJcbiAgICAgICAgICAgIGlmICh4IDwgbG93ZXJCb3VuZCkgeCA9IGxvd2VyQm91bmQ7XHJcbiAgICAgICAgICAgIGlmICh4ID4gdXBwZXJCb3VuZCkgeCA9IHVwcGVyQm91bmQ7XHJcbiAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHggPSBzaWduKHgpICogTWF0aC5mbG9vcihNYXRoLmFicyh4KSk7XHJcbiAgICAgICAgeCA9IHggJSBtb2R1bG9WYWw7XHJcblxyXG4gICAgICAgIGlmICghdHlwZU9wdHMudW5zaWduZWQgJiYgeCA+PSBtb2R1bG9Cb3VuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4geCAtIG1vZHVsb1ZhbDtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVPcHRzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgICAgICAgIHggKz0gbW9kdWxvVmFsO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHggPT09IC0wKSB7IC8vIGRvbid0IHJldHVybiBuZWdhdGl2ZSB6ZXJvXHJcbiAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG59XHJcblxyXG5jb252ZXJzaW9uc1tcInZvaWRcIl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJib29sZWFuXCJdID0gZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgcmV0dXJuICEhdmFsO1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJieXRlXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbig4LCB7IHVuc2lnbmVkOiBmYWxzZSB9KTtcclxuY29udmVyc2lvbnNbXCJvY3RldFwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oOCwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcclxuXHJcbmNvbnZlcnNpb25zW1wic2hvcnRcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDE2LCB7IHVuc2lnbmVkOiBmYWxzZSB9KTtcclxuY29udmVyc2lvbnNbXCJ1bnNpZ25lZCBzaG9ydFwiXSA9IGNyZWF0ZU51bWJlckNvbnZlcnNpb24oMTYsIHsgdW5zaWduZWQ6IHRydWUgfSk7XHJcblxyXG5jb252ZXJzaW9uc1tcImxvbmdcIl0gPSBjcmVhdGVOdW1iZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiBmYWxzZSB9KTtcclxuY29udmVyc2lvbnNbXCJ1bnNpZ25lZCBsb25nXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcclxuXHJcbmNvbnZlcnNpb25zW1wibG9uZyBsb25nXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogZmFsc2UsIG1vZHVsb0JpdExlbmd0aDogNjQgfSk7XHJcbmNvbnZlcnNpb25zW1widW5zaWduZWQgbG9uZyBsb25nXCJdID0gY3JlYXRlTnVtYmVyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogdHJ1ZSwgbW9kdWxvQml0TGVuZ3RoOiA2NCB9KTtcclxuXHJcbmNvbnZlcnNpb25zW1wiZG91YmxlXCJdID0gZnVuY3Rpb24gKFYpIHtcclxuICAgIGNvbnN0IHggPSArVjtcclxuXHJcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSBmaW5pdGUgZmxvYXRpbmctcG9pbnQgdmFsdWVcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcInVucmVzdHJpY3RlZCBkb3VibGVcIl0gPSBmdW5jdGlvbiAoVikge1xyXG4gICAgY29uc3QgeCA9ICtWO1xyXG5cclxuICAgIGlmIChpc05hTih4KSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBOYU5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbn07XHJcblxyXG4vLyBub3QgcXVpdGUgdmFsaWQsIGJ1dCBnb29kIGVub3VnaCBmb3IgSlNcclxuY29udmVyc2lvbnNbXCJmbG9hdFwiXSA9IGNvbnZlcnNpb25zW1wiZG91YmxlXCJdO1xyXG5jb252ZXJzaW9uc1tcInVucmVzdHJpY3RlZCBmbG9hdFwiXSA9IGNvbnZlcnNpb25zW1widW5yZXN0cmljdGVkIGRvdWJsZVwiXTtcclxuXHJcbmNvbnZlcnNpb25zW1wiRE9NU3RyaW5nXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcclxuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xyXG5cclxuICAgIGlmIChvcHRzLnRyZWF0TnVsbEFzRW1wdHlTdHJpbmcgJiYgViA9PT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBcIlwiO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBTdHJpbmcoVik7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcIkJ5dGVTdHJpbmdcIl0gPSBmdW5jdGlvbiAoViwgb3B0cykge1xyXG4gICAgY29uc3QgeCA9IFN0cmluZyhWKTtcclxuICAgIGxldCBjID0gdW5kZWZpbmVkO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IChjID0geC5jb2RlUG9pbnRBdChpKSkgIT09IHVuZGVmaW5lZDsgKytpKSB7XHJcbiAgICAgICAgaWYgKGMgPiAyNTUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IGlzIG5vdCBhIHZhbGlkIGJ5dGVzdHJpbmdcIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJVU1ZTdHJpbmdcIl0gPSBmdW5jdGlvbiAoVikge1xyXG4gICAgY29uc3QgUyA9IFN0cmluZyhWKTtcclxuICAgIGNvbnN0IG4gPSBTLmxlbmd0aDtcclxuICAgIGNvbnN0IFUgPSBbXTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XHJcbiAgICAgICAgY29uc3QgYyA9IFMuY2hhckNvZGVBdChpKTtcclxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID4gMHhERkZGKSB7XHJcbiAgICAgICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjKSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICgweERDMDAgPD0gYyAmJiBjIDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IG4gLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkID0gUy5jaGFyQ29kZUF0KGkgKyAxKTtcclxuICAgICAgICAgICAgICAgIGlmICgweERDMDAgPD0gZCAmJiBkIDw9IDB4REZGRikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBjICYgMHgzRkY7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IGQgJiAweDNGRjtcclxuICAgICAgICAgICAgICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoKDIgPDwgMTUpICsgKDIgPDwgOSkgKiBhICsgYikpO1xyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBVLmpvaW4oJycpO1xyXG59O1xyXG5cclxuY29udmVyc2lvbnNbXCJEYXRlXCJdID0gZnVuY3Rpb24gKFYsIG9wdHMpIHtcclxuICAgIGlmICghKFYgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBpcyBub3QgYSBEYXRlIG9iamVjdFwiKTtcclxuICAgIH1cclxuICAgIGlmIChpc05hTihWKSkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIFY7XHJcbn07XHJcblxyXG5jb252ZXJzaW9uc1tcIlJlZ0V4cFwiXSA9IGZ1bmN0aW9uIChWLCBvcHRzKSB7XHJcbiAgICBpZiAoIShWIGluc3RhbmNlb2YgUmVnRXhwKSkge1xyXG4gICAgICAgIFYgPSBuZXcgUmVnRXhwKFYpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBWO1xyXG59O1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webidl-conversions/lib/index.js\n");

/***/ })

};
;